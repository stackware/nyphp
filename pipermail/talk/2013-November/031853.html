<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-51353372-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-51353372-3');
</script>
   <TITLE> [nycphp-talk] Why do unit tests not inherit?
   </TITLE>
   <LINK REL="Index" HREF="http://nyphp.org/pipermail/talk/2013-November/index.html" >
   <LINK REL="made" HREF="mailto:talk%40lists.nyphp.org?Subject=Re:%20Re%3A%20%5Bnyphp-talk%5D%20Why%20do%20unit%20tests%20not%20inherit%3F&In-Reply-To=%3C528FB463.6010009%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="031850.html">
   <LINK REL="Next"  HREF="031870.html">
 <meta name="description" content="PHP jobs stackware web application support and development forums for Mongo LAMP MySQL SQL Windows IIS Linux." />
<meta name="author" content="Stackware Web Development - http://stackware.com" />
<meta name="verify-v1" content="zWMoPwMn/dolscLkjLXTpRqgr9K8bzlzL1vM9WTjpHc=" />
<meta name="msvalidate.01" content="F85F81C1D0BAB5C349E8395628845E27" />
<meta name="y_key" content="265502be3db4fb6e" />
</HEAD>
         <BODY BGCOLOR="#ffffff">
<h1 style="float: right; margin: 0; padding: 0 0 0 15px;"><a href="https://www.meetup.com/new-york-php/">NYCPHP Meetup</a></h1><h1><a href="http://www.nyphp.org">NYPHP.org</a></h1>
   <H1>[nycphp-talk] Why do unit tests not inherit?</H1>
    <B>Gary A. Mort</B> 
    <A HREF="mailto:talk%40lists.nyphp.org?Subject=Re:%20Re%3A%20%5Bnyphp-talk%5D%20Why%20do%20unit%20tests%20not%20inherit%3F&In-Reply-To=%3C528FB463.6010009%40gmail.com%3E"
       TITLE="[nycphp-talk] Why do unit tests not inherit?">garyamort at gmail.com
       </A><BR>
    <I>Fri Nov 22 14:45:39 EST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="031850.html">[nycphp-talk] Why do unit tests not inherit?
</A></li>
        <LI>Next message: <A HREF="031870.html">[nycphp-talk] Why do unit tests not inherit?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31853">[ date ]</a>
              <a href="thread.html#31853">[ thread ]</a>
              <a href="subject.html#31853">[ subject ]</a>
              <a href="author.html#31853">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks Robert...  I may be misunderstanding something here:

On 11/15/2013 12:57 PM, Robert Stoll wrote:
&gt;<i> I am not sure if we talk about the same. Just to avoid misunderstands I am going to outline a little bit more what I
</I>&gt;<i> meant. I did not mean that each method of a class has to have its one test class. But each method of a class A should
</I>&gt;<i> have an own test method in the test class T. And if the method of class A has branches, let's say one if-statement, then
</I>&gt;<i> the ideal case would be that you create two test methods in C which covers both cases. Once for the case that the
</I>&gt;<i> if-condition evaluates to true and once to false.
</I>&gt;<i> For example:
</I>&gt;<i>
</I>&gt;<i> class A{
</I>&gt;<i>      private $_isActive=false;
</I>&gt;<i>      function isActive(){
</I>&gt;<i>          return $this-&gt;_isActive;
</I>&gt;<i>      }
</I>&gt;<i>      function foo(){
</I>&gt;<i>          $this-&gt;_isActive=true;
</I>&gt;<i>      }
</I>&gt;<i>
</I>&gt;<i>      function bar(){
</I>&gt;<i>          if($isActive){
</I>&gt;<i>              doesThis();
</I>&gt;<i>          } else{
</I>&gt;<i>              doesThat();
</I>&gt;<i>          }
</I>&gt;<i>      }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> class T extends SomeTestFramework{
</I>&gt;<i>      public function testFoo_Standard_IsActiveSetToTrue (){
</I>&gt;<i>          // arrange
</I>&gt;<i>          // act
</I>&gt;<i>          // assert
</I>&gt;<i>      }
</I>&gt;<i>      public function testBar_IsActiveIsTrue_DoesThis(){}
</I>
I am assuming that there is no unit testing magic which is setting 
things, so this method would actually be:

public function testBar_IsActiveIsTrue_DoesThis(){

// create an object $testObject of class A
// call $testObject-&gt;foo() to make it active
// Test that $testObject-&gt;isActive returns true
// Test that $testObject-&gt;bar executes doesThis()

}


public function testBar_IsActiveIsFalse_DoesThat(){

// create an object $testObject of class A
// Test that $testObject-&gt;isActive returns false
// Test that $testObject-&gt;bar executes doesThat()

}


It's with the above commented steps that I have an issue.  Primarily 
because in practice, if someone creates:

Class APrime extend A{}

Then they also create

class TPrime extends SomeTestFramework{

     function bar(){
         if($isActive){
             doesThis();
         } else{
             doesNOTDOThat();
         }

}

In in TPrime will be:


public function testBar_IsActiveIsTrue_DoesThis(){

// create an object $testObject of class APrime
// call $testObject-&gt;foo() to make it active
// Test that $testObject-&gt;isActive returns true
// Test that $testObject-&gt;bar executes doesThis()

}


public function testBar_IsActiveIsFalse_DoesNOTDOThat(){

// create an object $testObject of class APrime
// Test that $testObject-&gt;isActive returns false
// Test that $testObject-&gt;bar executes doesNOTDOThat()

}


So everything has been cut and pasted from one to the other.  The only 
difference is that APrime calls doesNOTDOThat instead of doesThat.  
Testing items where taken from one to the other, with minor editing 
changes to half of the new tests to change doesThat to doesNOTDOThat

Now to extend this further, let's say a year later someone goes in and 
modifies class A:

class A{
     private $_isActive=false;

      public function __construct($active = false) {
          $this-&gt;$_isActive = $active;
     }


Everything works pretty well for a while because no one is actually 
USING the new parameter added to object construction.  Months pass:


Then the class needs to have THREE states, and is active is easily 
modified for that:

  function bar(){
         if($isActive === true){
             doesThis();
         } else if ($isActive === false) {
             doesThat();
         } else {
	    doesSomethingEntirelyDifferent();	
	}
  }


The testing class is updated with the appropriate:

public function testBar_IsActiveThirdState_DoesSomethingEntirelyDeffierentThat(){

// create an object $testObject of class A using $testObject = new A(3);
// Test that $testObject-&gt;isActive returns 3
// Test that $testObject-&gt;bar executes doesSomethingEntirelyDifferent()

}




And here is where the maintenance fun begins!

Class APrime was forgotten about - so it wasn't updated to use the new 
tristate logic.  APrime still passes all the tests associated with it, 
so from the Unit Tests all looks good.

The very reason we wrote unit tests, to discover when changes break 
compatibility, and because we just copy and paste tests from one test 
class to the next, the tests don't tell us all that they should and could.


The more I think about it, the more I think that inheritance is not the 
answer because we just would have overwritten some of the tests anyway 
and would still end up failing.

Ideally, what we should be doing is:
When testing a subclass, after running the tests for the subclass, we 
should also load the tests for the parent class and run them. Somehow we 
need to add a blacklist of tests not to run, ie:
For APrime we want to run:
TPrime::testBar_IsActiveIsTrue_DoesThis, 
TPrime::testBar_IsActiveIsTrue_DoesNOTDOTHAT
and run
all tests from class T EXCEPT FOR TPrime::testBar_IsActiveIsTrue_DoesThat

 From a test report perspective, I want to know that:
Class APrime is sane
Class APrime is also a sane subclass of class A

If tests are run this way, then when the modifications I've seen happen 
such as the above are done, our unit tests will come back and say:
Class APrime is sane
Class APrime is not a sane subclass of class A

Because it will fail the newly added and not excluded test that 
testBar_IsActiveThirdState_DoesSomethingEntirelyDeffierentThat

That then immediately tells the project maintainers that the new changes 
are affecting some other areas that they had not considered.

Or, a more likely occurrence, when some downstream project team imports 
the new library and then uses their own custom classes, they will know 
that the API for class A was changed in the new API and they can decide 
how they should handle it in their own project.

Sorry for the really length explanation and if I'm just missing 
something &quot;obvious&quot; about how PHPUnit should be configured that would 
have caught this sort of thing.
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="031850.html">[nycphp-talk] Why do unit tests not inherit?
</A></li>
	<LI>Next message: <A HREF="031870.html">[nycphp-talk] Why do unit tests not inherit?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31853">[ date ]</a>
              <a href="thread.html#31853">[ thread ]</a>
              <a href="subject.html#31853">[ subject ]</a>
              <a href="author.html#31853">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.nyphp.org/mailman/listinfo/talk">More information about the talk
mailing list</a><br>
</body></html>
