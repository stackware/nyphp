<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-51353372-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-51353372-3');
</script>
   <TITLE> [nycphp-talk] data modelling vs. db design (was: ER	Diagramtoolfor MySQL/OS X)
   </TITLE>
   <LINK REL="Index" HREF="http://nyphp.org/pipermail/talk/2005-October/index.html" >
   <LINK REL="made" HREF="mailto:talk%40lists.nyphp.org?Subject=Re:%20Re%3A%20%5Bnyphp-talk%5D%20data%20modelling%20vs.%20db%20design%20%28was%3A%20ER%0A%09Diagramtoolfor%20MySQL/OS%20X%29&In-Reply-To=%3C000301c5ced2%249c4b9420%246601a8c0%40MZ%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016254.html">
   <LINK REL="Next"  HREF="016258.html">
 <meta name="description" content="PHP jobs stackware web application support and development forums for Mongo LAMP MySQL SQL Windows IIS Linux." />
<meta name="author" content="Stackware Web Development - http://stackware.com" />
<meta name="verify-v1" content="zWMoPwMn/dolscLkjLXTpRqgr9K8bzlzL1vM9WTjpHc=" />
<meta name="msvalidate.01" content="F85F81C1D0BAB5C349E8395628845E27" />
<meta name="y_key" content="265502be3db4fb6e" />
</HEAD>
         <BODY BGCOLOR="#ffffff">
<h1 style="float: right; margin: 0; padding: 0 0 0 15px;"><a href="https://www.meetup.com/new-york-php/">NYCPHP Meetup</a></h1><h1><a href="http://www.nyphp.org">NYPHP.org</a></h1>
   <H1>[nycphp-talk] data modelling vs. db design (was: ER	Diagramtoolfor MySQL/OS X)</H1>
    <B>Hans Zaunere</B> 
    <A HREF="mailto:talk%40lists.nyphp.org?Subject=Re:%20Re%3A%20%5Bnyphp-talk%5D%20data%20modelling%20vs.%20db%20design%20%28was%3A%20ER%0A%09Diagramtoolfor%20MySQL/OS%20X%29&In-Reply-To=%3C000301c5ced2%249c4b9420%246601a8c0%40MZ%3E"
       TITLE="[nycphp-talk] data modelling vs. db design (was: ER	Diagramtoolfor MySQL/OS X)">lists at zaunere.com
       </A><BR>
    <I>Tue Oct 11 22:13:59 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="016254.html">[nycphp-talk] data modelling vs. db design (was: ER Diagram	toolfor MySQL/OS X)
</A></li>
        <LI>Next message: <A HREF="016258.html">[nycphp-talk] data modelling vs. db design (was: ER	Diagramtoolfor MySQL/OS X)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16257">[ date ]</a>
              <a href="thread.html#16257">[ thread ]</a>
              <a href="subject.html#16257">[ subject ]</a>
              <a href="author.html#16257">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

Phil Duffy wrote on Tuesday, October 11, 2005 9:05 AM:
&gt;<i> &gt; -----Original Message-----
</I>&gt;<i> &gt; From: <A HREF="http://lists.nyphp.org/mailman/listinfo/talk">talk-bounces at lists.nyphp.org</A>
</I>&gt;<i> &gt; [mailto:<A HREF="http://lists.nyphp.org/mailman/listinfo/talk">talk-bounces at lists.nyphp.org</A>] On Behalf Of Hans Zaunere Sent:
</I>&gt;<i> &gt; Monday, October 10, 2005 7:09 PM 
</I>&gt;<i> &gt; To: 'NYPHP Talk'
</I>&gt;<i> &gt; Subject: Re: [nycphp-talk] data modelling vs. db design (was: ER Diagram
</I>&gt;<i> &gt; toolfor MySQL/OS X) Normalization is often one of the most
</I>&gt;<i> &gt; misunderstood aspects of relational databases.  Of course, it's what
</I>&gt;<i> &gt; makes a relational database relational, and we're all taught that
</I>&gt;<i> &gt; you're not worth a cent unless you only work in the 5th normalized
</I>&gt;<i> &gt; form.  
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Well, perhaps if you're a mathematician, then that's correct.  The
</I>&gt;<i> &gt; reality is that over-normalization can kill a project just as much as
</I>&gt;<i> &gt; under-normalization.  Don't forget - at least from the old SQL books I
</I>&gt;<i> &gt; learned from - why normalization was being preached.  &quot;Don't have
</I>&gt;<i> &gt; duplicate data!&quot; was often the mantra.  If you had more than one guy
</I>&gt;<i> &gt; named &quot;John&quot;, then you need to have a table of first names, with a
</I>&gt;<i> &gt; lookup table relating first names with the other data you're storing. 
</I>&gt;<i> &gt; Seems rediculous, right? 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The practice of heavy normalization was based on some old, bygone,
</I>&gt;<i> &gt; concerns, namely &quot;storage is expensive.&quot;  Add in academic
</I>&gt;<i> &gt; chest-beating, and pretty soon you have a table for every letter of the
</I>&gt;<i> &gt; alphabet and look-up tables to match.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; As I think we generally find, with the abundance of hardware resources,
</I>&gt;<i> &gt; normalization is reduced to only an element of good design.  Sure,
</I>&gt;<i> &gt; performance can still be a factor, but let's consider the performance
</I>&gt;<i> &gt; of an entire system, and not just what's happening in the database.
</I>&gt;<i> 
</I>&gt;<i> &lt;snip&gt;
</I>&gt;<i> 
</I>&gt;<i> Hans,
</I>&gt;<i> 
</I>&gt;<i> While I agree with your general message, I have a reservation about the
</I>&gt;<i> &quot;storage is expensive&quot; specific example.  Having been around since before
</I>&gt;<i> Boole and Babbage, I can't even recall in the &quot;old days&quot; when developers
</I>&gt;<i> were slavish about &quot;storage is expensive&quot;.  We sought opportunities to
</I>&gt;<i> reduce storage, when that was practical, but only in very specialized
</I>&gt;<i> applications did we go out of our way to conserve disk storage.  The
</I>&gt;<i> primary issue was data consistency and software maintainability.  Lack of
</I>&gt;<i> normalization created situations which encouraged users to create
</I>&gt;<i> inconsistent data.  For example, consider a pre-relational system in
</I>&gt;<i> healthcare that recognized two 'pseudo-entities', physicians and patients
</I>&gt;<i> (pseudo in the sense we now recognize these as roles as opposed to
</I>&gt;<i> fundamental entities).  Each pseudo-entity had its own basic record to
</I>&gt;<i> contain address, telephone number and other attributes.  That worked as
</I>&gt;<i> long as the physician never became a patient.  However, a change to a
</I>&gt;<i> physician/patient's record created an inconsistency in the changed
</I>&gt;<i> attribute, e.g., the address.
</I>&gt;<i> 
</I>&gt;<i> The second issue was software maintenance.  There were situations where
</I>&gt;<i> one record's structure might be modified while the other was not.
</I>
Good points, and I think you raise an important issue, namely, normalization
as a mechanism for separation and isolation.

&gt;<i> I believe it was a natural progression from normalization of databases to
</I>&gt;<i> object-oriented design, because the latter encouraged all interactions
</I>&gt;<i> with the database to be performed in a single module.  I know of at least
</I>&gt;<i> one situation in healthcare where that limitation in the existing systems
</I>&gt;<i> nearly killed a patient.
</I>
Ah hah!  Separation and isolation.  There is always the consideration of
what perspective we're looking at, and at the end, who is saying
normalization.  I think the storage reasoning has come from - at least in my
experience when browsing academic SQL references - a largely idealistic way
of storing data.  Perhaps storage was or wasn't really expensive, but it was
neat to not store redundant data, as the first few normal-forms try to
address:

<A HREF="http://www.datamodel.org/NormalizationRules.html">http://www.datamodel.org/NormalizationRules.html</A>

That's from the data-structures-are-cool-and-I'm-not-an-implementer
department, which begins down the road of:

<A HREF="http://en.wikipedia.org/wiki/Database_normalization#Sixth_normal_form">http://en.wikipedia.org/wiki/Database_normalization#Sixth_normal_form</A>
<A HREF="http://www.bkent.net/Doc/simple5.htm">http://www.bkent.net/Doc/simple5.htm</A>

and eventually to:

<A HREF="http://www.nerdbooks.com/item.php?id=1558608559">http://www.nerdbooks.com/item.php?id=1558608559</A>

Not a bad thing, but not something I'd be ready to recommend to a customer
:<i>)
</I>
&gt;<i>From a developer's perspective, however, the more important issue, as you
</I>point out, is a good, clean, representation of data.  And, as hardware
resources become cheaper, that might mean that it's OK to have
redundant/repeating data, and still be correctly normalized and
architectured.

&gt;<i> But your principle point is that database design (and object design by
</I>&gt;<i> extension in my opinion) is still an art form.  Both database and object
</I>&gt;<i> design should look upon the 'rules' as significant guidelines.  Understand
</I>&gt;<i> when to bypass these rules, and document those reasons (conditions may
</I>&gt;<i> change in the future and others will probably have to clean up the
</I>&gt;<i> situation).
</I>
Exactly - it's a balance between what works in a sensible way, and how
you're supposed to do it.  As some of the links above mention, they're
discussing &quot;relational database theory.&quot;  A lot of the work these guys do is
great, and the basis for much of the technology we have today.  But as
architects and implementers on the front-lines, it's our job to find that
happy place between the theory and practical, cost effective software.

&gt;<i> I liked your example of normalizing the string 'John', which underlines
</I>&gt;<i> the absurdity of over-normalization.  For me, appropriate normalization
</I>&gt;<i> begins with the recognition of the fundamental entities in a system and a
</I>&gt;<i> distinction between real world-modeled entities (e.g., a Person) as
</I>&gt;<i> opposed to system-internal entities (e.g., a web page).  If I come to a
</I>&gt;<i> branch in the road at which normalization or de-normalization both offer
</I>&gt;<i> advantages, I am most likely to take the normalization branch, make a
</I>&gt;<i> mental note and if I later discover that creates a significant
</I>&gt;<i> performance issue that can't be otherwise corrected, I would de-normalize
</I>&gt;<i> that area of the system intentionally (documenting my reasons and the
</I>&gt;<i> implementation). 
</I>&gt;<i> 
</I>&gt;<i> It would be interesting to see if others have approached normalization
</I>&gt;<i> guidelines differently.  I won't claim the above is the only way to do
</I>&gt;<i> database design - it is still an art form after all.
</I>
I approach it in much the same way, however often take de-normalization if
all other things are equal.  Recognition of fundamental entities is really
the driver behind normalization in most environments I come across, and
without it, the total system, in terms of code/DB writing, style, and
maintainability, system performance, and future system changes by external
developers, is usually happier with a bit more data consolidation.


Good talk Phil,

---
Hans Zaunere / President / New York PHP
   www.nyphp.org  /  www.nyphp.com



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016254.html">[nycphp-talk] data modelling vs. db design (was: ER Diagram	toolfor MySQL/OS X)
</A></li>
	<LI>Next message: <A HREF="016258.html">[nycphp-talk] data modelling vs. db design (was: ER	Diagramtoolfor MySQL/OS X)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16257">[ date ]</a>
              <a href="thread.html#16257">[ thread ]</a>
              <a href="subject.html#16257">[ subject ]</a>
              <a href="author.html#16257">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.nyphp.org/mailman/listinfo/talk">More information about the talk
mailing list</a><br>
</body></html>
