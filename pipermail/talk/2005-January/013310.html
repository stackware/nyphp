<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-51353372-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-51353372-3');
</script>
   <TITLE> [nycphp-talk] MySQL doubt
   </TITLE>
   <LINK REL="Index" HREF="http://nyphp.org/pipermail/talk/2005-January/index.html" >
   <LINK REL="made" HREF="mailto:talk%40lists.nyphp.org?Subject=Re:%20Re%3A%20%5Bnyphp-talk%5D%20MySQL%20doubt&In-Reply-To=%3C41E965BA.9080809%40nostromo.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013309.html">
   <LINK REL="Next"  HREF="013311.html">
 <meta name="description" content="PHP jobs stackware web application support and development forums for Mongo LAMP MySQL SQL Windows IIS Linux." />
<meta name="author" content="Stackware Web Development - http://stackware.com" />
<meta name="verify-v1" content="zWMoPwMn/dolscLkjLXTpRqgr9K8bzlzL1vM9WTjpHc=" />
<meta name="msvalidate.01" content="F85F81C1D0BAB5C349E8395628845E27" />
<meta name="y_key" content="265502be3db4fb6e" />
</HEAD>
         <BODY BGCOLOR="#ffffff">
<h1 style="float: right; margin: 0; padding: 0 0 0 15px;"><a href="https://www.meetup.com/new-york-php/">NYCPHP Meetup</a></h1><h1><a href="http://www.nyphp.org">NYPHP.org</a></h1>
   <H1>[nycphp-talk] MySQL doubt</H1>
    <B>Mark Horton</B> 
    <A HREF="mailto:talk%40lists.nyphp.org?Subject=Re:%20Re%3A%20%5Bnyphp-talk%5D%20MySQL%20doubt&In-Reply-To=%3C41E965BA.9080809%40nostromo.net%3E"
       TITLE="[nycphp-talk] MySQL doubt">mark at nostromo.net
       </A><BR>
    <I>Sat Jan 15 13:49:30 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="013309.html">[nycphp-talk] MySQL doubt
</A></li>
        <LI>Next message: <A HREF="013311.html">[nycphp-talk] MySQL doubt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13310">[ date ]</a>
              <a href="thread.html#13310">[ thread ]</a>
              <a href="subject.html#13310">[ subject ]</a>
              <a href="author.html#13310">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ophir Prusak wrote:
&gt;<i> As long as we're on the subject, could someone shed some light on this behavior?
</I>&gt;<i> It caused me a good amount of hair pulling until I realized what mysql
</I>&gt;<i> was doing.
</I>&gt;<i> 
</I>&gt;<i> Why doesn't MySQL use the primary key in the second query?
</I>&gt;<i> I would think that count doesn't care what column I use, but obviously it does.
</I>
I think what many have said on this is accurate.  I wanted to further 
say that the short answer to your question is that if the optimizer 
detects it will scan more than 30% of the index tree then it may decide 
not to use the index at all and do a full table scan.  (According to the 
recent docs there are other variables taken into account, but I believe 
the 30% rule is a significant factor.)

You table has 43894 rows and your where clause indicates it will scan 
about 75% of the index tree, thus your second query does a full table scan.

However, the results of your first query can be wholly computed without 
touching the data at all, so it decides not to do a table scan.  You are 
fetching rev_id and using rev_id in the where clause, so it gets 
everything it needs from the index tree.  (It doesn't always work like 
this, but I believe it does for integer based indexes.)

Why would it decide to do a full table scan?  My guess is that it 
doesn't take into account that rev_id is an auto_increment column.  So 
it doesn't know that it can simply start at 10001 and work its way up 
using the index.  For all it knows your index could be a normal index 
with duplicates.  I believe this is related to cardinality.  IOW it 
decides it would be faster to only reference the data (1 disk seek) 
instead of the index tree then also fetch the data (possibly 2 disk 
seeks).

You can hand optimize the second query with 'force index' if you want. 
I've also read that you can use 'max_seeks_for_key' to manipulate some 
of the behavior, although I've never used it myself.

Mark

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013309.html">[nycphp-talk] MySQL doubt
</A></li>
	<LI>Next message: <A HREF="013311.html">[nycphp-talk] MySQL doubt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13310">[ date ]</a>
              <a href="thread.html#13310">[ thread ]</a>
              <a href="subject.html#13310">[ subject ]</a>
              <a href="author.html#13310">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.nyphp.org/mailman/listinfo/talk">More information about the talk
mailing list</a><br>
</body></html>
