<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-51353372-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-51353372-3');
</script>
   <TITLE> [nycphp-talk] Is it worth learning Python too? 
   </TITLE>
   <LINK REL="Index" HREF="http://nyphp.org/pipermail/talk/2004-April/index.html" >
   <LINK REL="made" HREF="mailto:talk%40lists.nyphp.org?Subject=Re:%20Re%3A%20%5Bnyphp-talk%5D%20Is%20it%20worth%20learning%20Python%20too%3F%20&In-Reply-To=%3C001e01c4228a%241101ac10%24e98d3818%40oberon1%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008999.html">
   <LINK REL="Next"  HREF="009000.html">
 <meta name="description" content="PHP jobs stackware web application support and development forums for Mongo LAMP MySQL SQL Windows IIS Linux." />
<meta name="author" content="Stackware Web Development - http://stackware.com" />
<meta name="verify-v1" content="zWMoPwMn/dolscLkjLXTpRqgr9K8bzlzL1vM9WTjpHc=" />
<meta name="msvalidate.01" content="F85F81C1D0BAB5C349E8395628845E27" />
<meta name="y_key" content="265502be3db4fb6e" />
</HEAD>
         <BODY BGCOLOR="#ffffff">
<h1 style="float: right; margin: 0; padding: 0 0 0 15px;"><a href="https://www.meetup.com/new-york-php/">NYCPHP Meetup</a></h1><h1><a href="http://www.nyphp.org">NYPHP.org</a></h1>
   <H1>[nycphp-talk] Is it worth learning Python too? </H1>
    <B>Tim Gales</B> 
    <A HREF="mailto:talk%40lists.nyphp.org?Subject=Re:%20Re%3A%20%5Bnyphp-talk%5D%20Is%20it%20worth%20learning%20Python%20too%3F%20&In-Reply-To=%3C001e01c4228a%241101ac10%24e98d3818%40oberon1%3E"
       TITLE="[nycphp-talk] Is it worth learning Python too? ">tgales at tgaconnect.com
       </A><BR>
    <I>Wed Apr 14 21:36:24 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="008999.html">[nycphp-talk] Is it worth learning Python too? 
</A></li>
        <LI>Next message: <A HREF="009000.html">[nycphp-talk] Is it worth learning Python too? 
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9005">[ date ]</a>
              <a href="thread.html#9005">[ thread ]</a>
              <a href="subject.html#9005">[ subject ]</a>
              <a href="author.html#9005">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="http://lists.nyphp.org/mailman/listinfo/talk">talk-bounces at lists.nyphp.org</A>
</I>&gt;<i> [mailto:<A HREF="http://lists.nyphp.org/mailman/listinfo/talk">talk-bounces at lists.nyphp.org</A>] On Behalf Of James Wetterau
</I>&gt;<i> Sent: Wednesday, April 14, 2004 2:35 PM
</I>&gt;<i> To: NYPHP Talk
</I>&gt;<i> Subject: Re: [nycphp-talk] Is it worth learning Python too?
</I>&gt;<i> 
</I>&gt;<i> &quot;Tim Gales&quot; says:
</I>&gt;<i> ...
</I>&gt;<i> &gt; &gt; Another important practical distinction is that a high-level 
</I>&gt;<i> &gt; &gt; language is presumably portable between different computers.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Who is doing the presuming in your view?
</I>&gt;<i> 
</I>&gt;<i> I am, but I think this is not an uncommon view of a key advantage of
</I>&gt;<i> high-level languages.
</I>&gt;<i> 
</I>&gt;<i> &gt; A language author creates a language to be useful.
</I>&gt;<i> 
</I>&gt;<i> At least in the case of C, a component of that usefulness was
</I>&gt;<i> portability across platforms, and I think today it is commonly 
</I>&gt;<i> expected that portability across platforms is a key aspect of the 
</I>&gt;<i> utility of high-level languages.
</I>&gt;<i> 
</I>&gt;<i> Kernighan and Ritchie, the authors of C say about C in their
</I>
Kernigan has said, &quot;C is entirely the work of Dennis Ritchie, 
I am but a popularizer...&quot;
(<A HREF="http://www-2.cs.cmu.edu/~mihaib/kernighan-interview/">http://www-2.cs.cmu.edu/~mihaib/kernighan-interview/</A>)
  
&gt;<i> classic book &quot;The C Programming Languages&quot;, 2nd ed., in the
</I>&gt;<i> introduction: &quot;Although C matches the capabilities of many computers, 
</I>&gt;<i> it is independent of any particular machine architecture.  With a 
</I>&gt;<i> little care, it is easy to write portable programs, that is, programs 
</I>&gt;<i> that can be run without change on a variety of hardware.  The standard 
</I>&gt;<i> makes portability issues explicit, and prescribes a set of
</I>&gt;<i> constants that characterize the machine on which the program is run.&quot;
</I>
Early C certainly did match the capabilities of the 'Digital 
Equipment Corp.'-like  machines of its day on which 
the Unix operating system was born. C operators bear 
such an uncanny resemblance to the underlying DEC assembly 
language instruction set, that an experienced Macro-11 
programmer (again of that time) might have tried looking up 
information on the SWAPB operator in the C language reference 
manual.

C was popularly thought of in its early days as a special-purpose 
language for Ken Thompson's experimental operating system.
I think most people agree that this proved eventually to be a 
misconception. Perhaps what clouded things was the way C seemed 
to evolve from Thompson's B language (which really was a special 
purpose language).

I am guessing at this, but I think that by the time the 
the book came out, the authors realized the C language could have 
more applications than just facilitating the porting of Unix.

Either way, C was ported to other Non-DEC like hardware and OSs, 
but only by creating what approaches being a Unix emulation 
layer in the runtime library for the different architectures.

Early C developers on non-unix platforms often used to say that they 
got NUXI 'd when their runtime implementation didn't implement the 
proper Unix (DEC) byte ordering.

My point here is that Ritchie may well have discovered the more 
general nature that C could become when he tried to implement 
the runtime library on different architectures.
(this is just conjecture on my part of course)

&gt;<i> 
</I>&gt;<i> I think the last sentence pertinent to the ANSI standard is
</I>&gt;<i> particularly telling -- portability, which was implicit in the 
</I>&gt;<i> language from very early on was made explicit in the standardization 
</I>&gt;<i> process of the 70s - 80s.
</I>&gt;<i> 
</I>&gt;<i> I am humbled to report, in the spirit of full disclosure, that the
</I>&gt;<i> text in the preface describes C as 'not a &quot;very high level&quot; language', 
</I>&gt;<i> and the text in the introduction describes it thus: &quot;C is a relatively 
</I>&gt;<i> 'low level' language.&quot;
</I>&gt;<i> 
</I>&gt;<i> So we seem to be in a semantic muddle.  Perhaps the correct
</I>&gt;<i> description would be: C is a standardized, portable relatively low 
</I>&gt;<i> level language for a high level language which is not a very high 
</I>&gt;<i> level language.
</I>&gt;<i> 
</I>&gt;<i> Maybe C would best be thought of as a middle level language; we could
</I>&gt;<i> call it a &quot;mezzanine&quot; language.
</I>&gt;<i> 
</I>&gt;<i> &gt; If he/she is successful, i.e. the language proves to be useful, 
</I>&gt;<i> &gt; other people port it to their systems so they can also take 
</I>&gt;<i> &gt; advantage of it.
</I>&gt;<i> 
</I>&gt;<i> Or in the caes of K&amp;R, I believe they did the first couple of ports
</I>&gt;<i> themselves.
</I>&gt;<i> 
</I>&gt;<i> &gt; Maybe some authors of languages have a design goal of not burning 
</I>&gt;<i> &gt; any bridges when it comes to portability -- since
</I>&gt;<i> 
</I>&gt;<i> In the case of K&amp;R they were going for portability from early on so
</I>&gt;<i> that they could easily move this large program
</I>
Now who's guilty of over-simplification (just joking) -- 
but there exits more than one layer to an operating 
system (hardly one program now matter how large). 
You know, like Linux is a kernel not an operating 
system.

&gt;<i> they had
</I>&gt;<i> written called &quot;Unix&quot; from one computer to another without having to 
</I>&gt;<i> rewrite huge chunks of it ever time.
</I>&gt;<i> 
</I>&gt;<i> ...
</I>&gt;<i> &gt; different types of systems, but by and large computer languages are 
</I>&gt;<i> &gt; created to get something done in one environment.
</I>&gt;<i> 
</I>&gt;<i> You may be right, but I don't believe that's the case with C/C++ and
</I>&gt;<i> Perl, to name just a few.
</I>&gt;<i> 
</I>&gt;<i> &gt; Even Java, which now even runs on my cell phone, was designed to run 
</I>&gt;<i> &gt; in a closed environment -- namely set top boxes.
</I>&gt;<i> 
</I>&gt;<i> Well, this is a simplification.  The first prototype of Java (called
</I>&gt;<i> &quot;Oak&quot;) was meant to run on a variety of set-top boxes (to get ready
</I>&gt;<i> for the coming &quot;digital convergence&quot;).  It was meant to be processor 
</I>&gt;<i> independent but to present a consistent programming environment and 
</I>&gt;<i> language.
</I>
Here again though, the runtime environment would provide a layer 
of abstraction -- this time as byte codes in a virtual machine.

&gt;<i> Evidently a contingent
</I>&gt;<i> at Sun expected that something that would be sort of a hybrid between 
</I>&gt;<i> cable modems, web tv, movies-on-demand, and TiVO, probably working 
</I>&gt;<i> over the internet, was going to be the next big thing in 1991.  Not 
</I>&gt;<i> completely wrong, but not exactly right.
</I>&gt;<i> 
</I>
Okay. The waters *are* rather murky here.
But maybe there is some relationship like:

B is to C as Oak is to Java.

If so, both roots of the languages seem to have started 
to help solve a specific problem as their main purpose for 
being, regardless of any later metamorphosis.


&gt;<i> ...
</I>&gt;<i> &gt; &gt; The definition of a compiler or interpreter or virtual machine 
</I>&gt;<i> &gt; &gt; includes the ability to read source code in a high-level language 
</I>&gt;<i> &gt; &gt; and generate correct executable programs for different kinds of 
</I>&gt;<i> &gt; &gt; computers.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; No, I don't think portability has anything to do
</I>&gt;<i> &gt; with being a high-level language.
</I>&gt;<i> 
</I>&gt;<i> Well, I think it's a commonly associated feature, and a
</I>&gt;<i> non-portable high-level language would be a gross exception.  
</I>&gt;<i> I suppose a vehicle doesn't have to have seats to be a car, 
</I>&gt;<i> and I don't know if the definition of &quot;car&quot; should include 
</I>&gt;<i> the idea that there are seats in it, but it seems to me to be 
</I>&gt;<i> the convention.  Similarly, I think portability is a commonly 
</I>&gt;<i> expected advantage to high level languages.
</I>
I would agree that people have come to expect a portable 
library with modern languages -- which in effect makes them 
portable.

It just strikes me that it is the level of abstraction or the 
distance from the hardware that is the main determining factor 
in where to place a language in terms of it being high level or 
low level.

And it was probably too harsh of me to say:
  &quot;I don't think portability has anything to do
   with being a high-level language.&quot;

Sorry 'bout that.

T. Gales &amp; Associates
'Helping People Connect with Technology'

<A HREF="http://www.tgaconnect.com">http://www.tgaconnect.com</A>



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008999.html">[nycphp-talk] Is it worth learning Python too? 
</A></li>
	<LI>Next message: <A HREF="009000.html">[nycphp-talk] Is it worth learning Python too? 
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9005">[ date ]</a>
              <a href="thread.html#9005">[ thread ]</a>
              <a href="subject.html#9005">[ subject ]</a>
              <a href="author.html#9005">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.nyphp.org/mailman/listinfo/talk">More information about the talk
mailing list</a><br>
</body></html>
